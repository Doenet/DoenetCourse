/**
 * Compute the lexicographic rank of an item based on the previous and next rank.
 * 
 * The algorithm first finds the position of the leftmost non-matching character
 * in prev and next. 
 * 
 * The identical substring of prev and next is used as the base of the sort order.
 * e.g. prev = 'abcde', next = 'abchi', str = 'abc'
 * If the first non-matching characters are not consecutive, the new order will
 * be generated by appending the character that is halfway in the alphabet
 * between the left and right character: str = 'abcf'
 * 
 * Otherwise, the first non-matching character from prev will be appended to the
 * sort order followed by the character halfway between the next character in 
 * prev and the end of alphabets.
 * 
 * @param {string} prev 
 * @param {string} next 
 */

export default function getSortOrder(prev, next) {
  var p, n, pos = 0, str = "";

  // find first non-matching character
  while (p == n) {
    p = pos < prev.length ? prev.charCodeAt(pos) : 96;
    n = pos < next.length ? next.charCodeAt(pos) : 123;
    pos++;
  }
  str = prev.slice(0, pos - 1); // get identical substring

  if (p === 96) {  // prev string equals next[0:pos]
    while (n === 97) {   // next character is 'a'
      n = pos < next.length ? next.charCodeAt(pos++) : 123;
      str += "a";  // insert an 'a' to match the 'a'
    }
    if (n === 98) {  // next character is 'b'
      str += "a";  // insert an 'a' to match the 'b'
      n = 123;
    }
  } else if (p + 1 === n) {   // prev, next are consecutive
    str += String.fromCharCode(p); // insert character from prev
    n = 123; // set to end of alphabet
    while ((p = pos < prev.length ? prev.charCodeAt(pos++) : 96) === 122) {
      str += "z"; // insert 'z' to match 'z'
    }
  }
    const middleCharacter = String.fromCharCode(Math.ceil((p + n) / 2));
  return str + middleCharacter;
}
